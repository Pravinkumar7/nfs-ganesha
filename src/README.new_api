Request for Comments: New fsal api

This README will be expanded as the work progresses.  It will/should
be turned into a fsal writer's HOWTO at some point.  This is a work in
progress and therefore still in flux at this point.

State
-----
This compiles but, being incomplete, it does not work.  No, I have not
done any testing because there is not enough of it yet to have any
meaningful testing.  If you find a bug, I won't be surprised.  Point it
out now so I don't have to search for it with gdb later.

This branch is based on my internal 'panasas' branch which has not been
rebased in a week or so.  The first patch of interest is:

   3bbec41ac770 "Add libraries flag for dlopen"

Contents
--------
The patch series comes in four parts following the 'dlopen' patch.

New infrastructure
	These are new files in src/FSAL which implement common
	fsal functions.

	I have squashed all my incremental changes so that you have
	a single file to look at for current state.  These are subject
	to further change and squashing.

VFS fsal
	These are new files that implement the VFS fsal over the
	new infrastructure.  The main.c file is the fsal object itself
	followed by export.c which implements fsal_export for VFS.
	handle.c implements fsal_obj_object.

	As with the infrastructure, these are whole files that were built
	up from incremental commits.  The set is by no means complete.

FSAL initialization
	This set of changes to the main server load and initialize
	the fsals.  Once they are all loaded, fsal_export objects
	are created as part of the export list initialization.  Lastly,
	the USE_SHARED_FSAL bits are deprecated.  This patch will grow.
	What is there now are the bits that had to be moved out of the
	way at this point.

Cache Inode changes
	Starting with b17f7dcf7d, "Change cache_inode.h to use new api"
	we invade the cache_inode_* code.  This series of patches replaces
	fsal_handle_t with a pointer to an allocated fsal_obj_handle and
	the various FSAL_* calls relevant to it.  Enough conversion was
	done to get successful compiles.  In cases where the new code
	is not ready to support core changes yet, some expedient hacks
	were done to get a clean compile.  This work will progress to
	where the use of fsal_handle_t is completely deprecated at which
	point, all definitions of it will be removed.

Things to look for
------------------
The new api uses an object oriented design pattern to implement a fsal.

Structure definitions
	The file include/fsal_api.h will contain the full fsal api. The
	only part visible to the server core is defined here.

	Each file that implements an object has its version of the
	object definition.  One element of this private definition is
	the public structure defined in fsal_api.h.  The rest of the
	elements are private to the fsal itself.  These two parts, the
	public and private are managed as follows:

	*	A pointer to the public structure is returned when
		the object is created.

	*	This pointer is used to access methods from it as in:

		exp_hdl->ops->lookup(exp_hdl, name, ...);

		Note that exp_hdl is used to dereference the method and
		it is also *always* the first argument to the
		method/function.  Think of it as the 'this' argument.

	*	Inside the method function, the public pointer gets
		dereferenced with the following sequence:

		struct vfs_fsal_export *myself;

		myself = container_of(exp_hdl, struct vfs_fsal_export, export);

		The 'container_of' is a macro that takes the public pointer/
		handle 'exp_hdl' which is indicated as the element 'export'
		of structure type 'vfs_fsal_export'.  Throughout the function
		where private elements are dereferenced, the 'myself'
		pointer is used. 'exp_hdl' is used in the public case.

Object usage
	Mutex locks and reference counts are used to manage both concurrent
	usage and state.  The reference counts are use to determine when the
	object is "free".

	Since we cannot create objects out of thin air, there is an order
	based on one object being the "context" in which the other is
	created.  In other words, a 'fsal_export' is created from the
	'fsal_module' that connects it to the backing store (filesystem).
	The same applies to a 'fsal_obj_handle' that only makes sense for
	a specific 'fsal_export'.

	When an object is created, it is returned with a reference already
	taken.  The callee of the creating method must then either keep
	a persistent reference to it or 'put' it back.  For example, a
	'fsal_export' gets created for each export in the configuration.
	a pointer to it gets saved in exportlist__ and it has a reference
	to reflect this.  It is now safe to use it to do a 'lookup' which
	will return a 'fsal_obj_handle' which can then be kept in a
	cache inode entry.  If we had done a 'put' on the export, it could
	be freed at any point and make a 'lookup' using it unsafe.

	In addition to a reference count, object that create other objects
	have a list of all the objects they create.  This serves two purposes.
	The obvious case is to keep the object "busy" until all of its
	children are freed.  Second, it provides a means to visit all of
	the objects it creates.

	Every object has a pointer to its parent.  This is used for such
	things as managing the object list and for calling methods on the
	parent.

Pointers vs. Structure copies
	In order to manage multiple fsals which have different sized
	private object storage, we only pass and save pointers.  This keeps
	all of the referencing structures of constant size.  The
	'container_of' manages both the differences in private structure
	sizes and the actual layout of the private structures.  This also
	saves the space and cpu overhead of expensive structure copies.

Public FSAL Structure definitions
	The 'ops' element is the only element of an object's public structure
	that is safe.  No upper level code should directly reference
	any other elements.  Common methods located in
	src/FSAL/fsal_commonlib.c are used instead.  No size assumptions
	should be made either because, other than the 'ops' element, all
	other elements are subject to change.  Think of them as 'protected'.
	The only reason they are declared in the public structure is
	because they are used in all fsals i.e. every 'fsal_export' has
	lock and reference count.

FSAL structure
--------------
The VFS fsal is the first candidate, primarily because it is the most
promising base for the new work our group is doing.  I have followed a
simple pattern for this fsal.

There is one file per object to be implemented.  'export.c' implements
'fsal_export' for VFS and 'main.c' implements 'fsal_module'. This allows
the declaration of the object methods as 'static'.  Only common methods
are declared publicly in src/include/FSAL/fsal_commonlib.h and implemented
in src/FSAL/fsal_commonlib.c.  Likewise common helper functions are in the
these files.

I have used new names for the public fsal structures on purpose.  All of the
old api structures will be deprecated and removed from fsal_types.h and at
that point, the compiler will find the usages that are still 'hiding'
and complain.  Otherwise, we could have subtle bugs arise from the change
in structure and especially the use of the 'old' structure.

At one level, it looks like the VFS fsal is a complete rewrite which is
partly true.  As with the structures and their names, I am forcing breakage
at compile time.

*	There is a significant amount of code re-use.  For example, a
	'lookup' for a handle is still the same sequence of syscalls or
	library calls.  That logic and the error paths have all been worked
	out.

*	Method functions now do only one thing.  The 'extra' bit that
	acquires attributes, for example, is gone.  If the upper layers
	want attributes, they should call the method to get them.  This
	makes things smaller and smaller is good.

*	Access checking and all the (see above) is also gone.  This is
	being moved to the core.  The fsal can assume that if the method
	is being called, it is ok to do the work.  If the action is not
	allowed, the core should never make the method call.

*	Along with access checking in one place in the core server, the
	fsal is responsible for managing the difference between what
	NFS wants and the resource (filesystem) it manages provides.  For
	example, the server assumes that every fsal supports ACLs.  If
	the resource does not support them or supports them in a different
	way, the fsal is responsible for managing the differences.

*	There are some linkages between an object and its 'parent' object.
	These are managed in two ways.  First, common functions are in
	fsal_commonlib.c so every fsal implementation can use them.  The
	second case is for functions that are fsal specific such as
	'lookup' which is a 'fsal_export' method that must have intimate
	knowledge of what a 'fsal_obj_handle' is.  In this case, a
	function prototype is defined in export.c so it can be included
	in the ops vector and the method is declared global (not static)
	in handle.c.  Function prototypes are declared in headers only
	if they are referenced by multiple modules.  The goal is to
	break as much incorrect code at the compile level as we can.
